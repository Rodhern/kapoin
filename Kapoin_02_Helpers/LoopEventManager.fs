// **** **** **** **** **** **** **** **** **** **** **** **** ****
// **  Copyright (c) 2017, Robert Nielsen. All rights reserved.  **
// **** **** **** **** **** **** **** **** **** **** **** **** ****

namespace Rodhern.Kapoin.Helpers.Events
  
  open System
  open System.Collections.Generic
  open UnityEngine
  open Rodhern.Kapoin.Helpers
  
  
  // #region Discriminated unions used as Loop event messages
  // Unfortunately there is limited support for nested classes in F#,
  // so we are left with these classes floating about in the root of
  // the namespace.
  // ---- ---- ---- ---- ---- ----
  
  /// The KSP game application itself may loose app focus (and continue
  /// running in the background), the game may pause (e.g. the F3 flight
  /// menu), and of course the player may exit the KSP app all together.
  type LoopMessageAppStateEvent =
       /// Game events 'onGamePause' and 'onGameUnpause'.
       | GamePause of ispaused: bool
       /// Application events when focus is lost and regained.
       | AppFocus of hasfocus: bool
       /// Application quit and suspend events.
       | AppQuit of unit
  
  /// The three types of scene changes that we listen for are, the simple
  /// scene load request, its sibling the scene switch request, and the
  /// event that triggers when game settings are changed (or applied).
  type LoopMessageSceneEvent =
       /// Game scene load request (an early scene load callback).
       | SceneLoadRequest of scene: GameScenes
       /// Game scene switch request.
       /// The parameter is (``from``, ``to``).
       | SceneSwitchRequest of GameScenes * GameScenes
       /// Triggered when new (or possibly unchanged) game settings are
       /// applied. Even though the scene is not reloaded, from a game addon
       /// point of view, the changes might be any bit as significant as a
       /// scene change.
       | GameSettingsApplied of unit
  
  /// The progress of the game state as it is created, loaded and saved.
  type LoopMessageGameStateEvent =
       /// Triggered when the game state is first established,
       /// at the beginning of the scene.
       | Created of game: Game
       /// Signals that the game state is saved (and ready for the time
       /// being). The game state is saved as part of exiting the current
       /// scene, but is saved at other occasions too.
       | Saved of game: Game
       /// Once the game state is 'Created', further initialization happens
       /// during either 'Load' or 'LoadRevert'.
       | Load of node: ConfigNode
       /// Initialization of the game state
       /// in case of reverted flights, loaded quick saves et cetera.
       | LoadRevert of node: ConfigNode
       /// The game state is saved several times, but most often in
       /// connection with scene changes.
       | Save of node: ConfigNode
  
  /// The level (i.e. the game scene) is made ready in several steps.
  /// In addition to the game state events, the level ready events tell when
  /// the level is loaded (basic initialization), when the GUI is ready
  /// (all stock elements loaded), and finally when the Application Toolbar
  /// is ready.
  type LoopMessageLevelReady =
       /// When 'LevelWasLoaded' triggers, it is a good time to adjust or
       /// activate the loops. Usually the game state is loaded, but not yet
       /// re-saved, at this point.
       | LevelWasLoaded of scene: GameScenes
       /// Usually we ignore 'LevelGUIReady'.
       | LevelGUIReady of scene: GameScenes
       /// Once 'ToolbarReady' triggers we may configure toolbar buttons.
       | ToolbarReady of unit
  
  /// The loop tick messages are the bread and butter of the loop messages.
  /// Technically the loop tick messages are not triggered by game events,
  /// but we think of the loop tick messages in the same way as we think of
  /// game event messages.
  type LoopMessageTick =
       /// All the loops are similar. The identification number, 0 through 9,
       /// is used to tell the loops apart, when more than one loop is needed.
       /// The loop with id '0' is named 'MainLoop'.
       | MainLoop
       /// Auxiliary loops, numbered 1 through 9.
       | ReducedLoop of int
    with
      /// Constructor for 'LoopMessageTick'.
      /// Valid values of n are 0, 1, 2, ..., 9.
      static member ofNb (n: int) =
        if n = 0 then
          MainLoop
         elif n < 0 then
          invalidArg "n" "Cannot be negative."
         elif n > 9 then
          invalidArg "n" "Only auxiliary loops 1 through 9 are defined."
         else
          ReducedLoop n
      /// Read-only property analogous to the 'ofNb' constructor parameter value.
      member ticktype.Nb with get () = match ticktype with | MainLoop -> 0 | ReducedLoop n -> n
  
  /// Loop messages are passed to 'LoopMonitor.Callback (msg)' in response to
  /// events, including loop ticks generated by the loop monitor.
  type LoopMessageType =
       /// DESC_MISS
       | AppState of LoopMessageAppStateEvent
       /// DESC_MISS
       | Scene of LoopMessageSceneEvent
       /// DESC_MISS
       | GameState of LoopMessageGameStateEvent
       /// DESC_MISS
       | Level of LoopMessageLevelReady
       /// DESC_MISS
       | Tick of LoopMessageTick
  
  // ---- ---- ---- ---- ---- ----
  // #endregion
  
  /// A record of the required parameters to activate a loop.
  type LoopTimingInformation =
     { /// The identification of the loop.
       /// Often obtained from 'LoopMessageTick.ofNb'.
       LoopId: LoopMessageTick
       /// The initial delay is the time, in seconds, from the loop is
       /// activated until the first tick message is triggered.
       InitialDelay: float32
       /// The repeat delay is the time, in seconds, in between ticks.
       RepeatDelay: float32
       /// The minimum delta universal time is a filtering mechanism.
       /// A tick message is only generated if at the time of the tick
       /// the UT (the universal game time) has advanced by at least the
       /// specified delta value since the previous generated tick message.
       /// By construction the first tick message should not be subject to
       /// filtering.
       /// Note that even if a tick message is filtered away the time until
       /// the next tick is unaffected, and that may lead to fewer than
       /// intended tick messages being generated. Imagine for instance a
       /// loop with a repeat delay of 10s and a minimum delta value of 12s.
       /// In this case, at normal playing speed, a tick message is generated
       /// at every other tick, i.e. approximately every 20s.
       MinimumDeltaUT: float }
  
  
  [< AbstractClass >]
  /// DESC_MISS
  type LoopMonitor (?name: string) =
    inherit SceneAddonBehaviour (defaultArg name "LoopMonitor")
    
    /// A collection of stubs, that is used in 'removecallbacks', to
    /// eventually remove the installed callbacks.
    let callbackremovers = new ResizeArray<Func<unit,unit>> ()
    
    /// A helper function for 'AddCallbacks' (invoked by 'Start'),
    /// that adds a aingle callback to the loop monitor.
    /// To add a callback you must provide a Unity style stub used
    /// to hook up the callback, a stub to remove the callback, and
    /// of course the callback itself.
    let addcallback (addfunc: 'T -> unit) (removefunc: 'T -> unit) (callback: 'T) =
        do fun () -> removefunc callback
           |> callbackremovers.Add
        do addfunc callback
    
    /// Remove all callbacks,
    /// and clear the 'callbackremovers' collection when done.
    /// Invoked by 'RemoveCallbacks', in turn invoked by 'OnDestroy'.
    let removecallbacks () =
        for remover in callbackremovers
         do remover.Invoke ()
        do callbackremovers.Clear ()
    
    /// DESC_MISS
    let queuedactions = new Queue<Action> ()
    
    /// DESC_MISS
    /// Used as a lock object for queued actions.
    let sceneisloading: GameScenes option ref = ref None
    
    /// The Universal Time of the earliest 'acceptable' tick.
    /// The times are updated as the ticks are generated.
    let earliestTickTime = Array.create 10 0.
    
    /// The minimum elapsed Universal Time between ticks.
    /// This is the individual settings for each of the up to ten loops.
    let minimumTickDelta = Array.create 10 0.
    
    /// The most important loop monitor member is without a doubt
    /// the virtual method 'Callback'.
    /// This member is marked 'abstract' in F#; it is the only loop monitor
    /// member to be marked abstract.
    /// Every default callback (implemented as private instance methods)
    /// will invoke 'Callback'.
    /// A 'LoopMonitor' descendant must provide an actual implementation
    /// for 'Callback'.
    /// Note: Virtual methods are quite uncommon in Unity patterns.
    abstract member Callback: LoopMessageType -> unit
    
    /// The default implementation of 'Start' does two things:
    /// It invokes 'AddCallbacks', and
    /// it marks the loop monitor with 'DontDestroyOnLoad'.
    /// A descendant class may provide a different implementation.
    member public monitor.Start () =
      monitor.AddCallbacks ()
      GameObject.DontDestroyOnLoad monitor
    
    /// The default implementation of 'OnDestroy' calls 'RemoveCallbacks';
    /// there seldom is a reason not to.
    member public monitor.OnDestroy () =
      monitor.RemoveCallbacks ()
      monitor.UnqueueActions ()
      base.OnDestroy ()
    
    /// DESC_MISS
    member public monitor.QueueAction (a: unit -> unit) =
      lock sceneisloading (fun () ->
        do queuedactions.Enqueue (new Action (a))
        if not (monitor.IsInvoking monitor.ProcessQueueHandlerName)
         then monitor.Invoke (monitor.ProcessQueueHandlerName, 0.5f) // TODO - Hardcoded timing - a better implementation might be advantageous
        )
    
    /// DESC_MISS
    member public monitor.UnqueueActions () =
      lock sceneisloading (fun () ->
        do queuedactions.Clear ()
        if monitor.IsInvoking monitor.ProcessQueueHandlerName
         then monitor.CancelInvoke monitor.ProcessQueueHandlerName
        )
    
    /// Returns the number of unprocessed queued actions.
    /// Used for diagnostic purposes, for instance to check if the
    /// number of queued actions keeps rising.
    member public monitor.NumberOfActionsQueued
      with get () = lock sceneisloading (fun () -> queuedactions.Count)
    
    /// DESC_MISS
    member private monitor.ProcessQueueItem () =
      lock sceneisloading (fun () ->
        if (Option.isNone !sceneisloading) && (queuedactions.Count > 0)
         then let firstaction = queuedactions.Dequeue ()
              do firstaction.Invoke ()
        if queuedactions.Count > 0
         then monitor.Invoke (monitor.ProcessQueueHandlerName, 0.2f) // TODO - Hardcoded timing - a better implementation might be advantageous
        )
    
    /// The name of the 'ProcessQueueItem' handler method, which is simply "ProcessQueueItem".
    member private monitor.ProcessQueueHandlerName
      with get () = "ProcessQueueItem"
    
    // #region Callbacks hardcoded as instance methods
    // ---- ---- ---- ---- ---- ----    
    
    member private monitor.GameStateCreated (game: Game) =
      game |> Created |> GameState |> monitor.Callback
    
    member private monitor.GameStateSaved (game: Game) =
      game |> Saved |> GameState |> monitor.Callback
    
    member private monitor.GameStateLoad (node: ConfigNode) =
      node |> Load |> GameState |> monitor.Callback
    
    member private monitor.GameStatePostLoad (node: ConfigNode) =
      node |> LoadRevert |> GameState |> monitor.Callback
    
    member private monitor.GameStateSave (node: ConfigNode) =
      node |> Save |> GameState |> monitor.Callback
    
    member private monitor.LevelWasLoaded (scene: GameScenes) =
      scene |> LevelWasLoaded |> Level |> monitor.Callback
    
    member private monitor.LevelWasLoadedGUIReady (scene: GameScenes) =
      scene |> LevelGUIReady |> Level |> monitor.Callback
    
    member private monitor.GUIApplicationLauncherReady () =
      () |> ToolbarReady |> Level |> monitor.Callback
    
    member private monitor.GameSceneSwitchRequested (fromto: GameEvents.FromToAction<GameScenes,GameScenes>) =
      (fromto.from, fromto.``to``) |> SceneSwitchRequest |> Scene |> monitor.Callback
    
    member private monitor.GameSceneLoadRequested (scene: GameScenes) =
      scene |> SceneLoadRequest |> Scene |> monitor.Callback
    
    member private monitor.GameSettingsApplied () =
      () |> GameSettingsApplied |> Scene |> monitor.Callback
    
    member private monitor.GamePause () =
      GamePause true |> AppState |> monitor.Callback
    
    member private monitor.GameUnpause () =
      GamePause false |> AppState |> monitor.Callback
    
    /// DESC_MISS
    member private monitor.TrackGameSceneLoadRequested (scene: GameScenes) =
      lock sceneisloading (fun () -> sceneisloading := Some scene)
    
    /// DESC_MISS
    member private monitor.TrackLevelWasLoaded (scene: GameScenes) =
      lock sceneisloading (fun () -> sceneisloading := None)
    
    /// A MonoBehaviour event (invoked by Unity reflection).
    member public monitor.OnApplicationFocus (hasfocus: bool) =
      base.OnApplicationFocus hasfocus
      hasfocus |> AppFocus |> AppState |> monitor.Callback
    
    /// A MonoBehaviour event (invoked by Unity reflection).
    member public monitor.OnApplicationPause (isPaused: bool) =
      base.OnApplicationPause isPaused
      () |> AppQuit |> AppState |> monitor.Callback
    
    /// A MonoBehaviour event (invoked by Unity reflection).
    member public monitor.OnApplicationQuit () =
      base.OnApplicationQuit ()
      () |> AppQuit |> AppState |> monitor.Callback
    
    /// An artificial event, triggered by a combination of
    /// LoopTickHandlerMain, LoopTickHandlerReduced1,
    /// LoopTickHandlerReduced2, ..., LoopTickHandlerReduced9 and
    /// InvokeRepeating from InvokeLoop.
    /// See LoopTimingInformation for more information on loop tick events.
    member public monitor.LoopTick (ticktypenb: int) =
      let ticktype = LoopMessageTick.ofNb ticktypenb // the message tick type
      let planettime = monitor.GetPlanetTime ticktype // the current Universal Time
      if earliestTickTime.[ticktypenb] <= planettime then
        earliestTickTime.[ticktypenb] <- planettime + minimumTickDelta.[ticktypenb] // update earliest tick time
        Tick ticktype |> monitor.Callback // invoke the callback (that is the whole point of the class after all)
       else
        () // ignore the tick because not enough Universal Time has passed
    
    member private lp.LoopTickHandlerMain () = lp.LoopTick 0
    member private lp.LoopTickHandlerReduced1 () = lp.LoopTick 1
    member private lp.LoopTickHandlerReduced2 () = lp.LoopTick 2
    member private lp.LoopTickHandlerReduced3 () = lp.LoopTick 3
    member private lp.LoopTickHandlerReduced4 () = lp.LoopTick 4
    member private lp.LoopTickHandlerReduced5 () = lp.LoopTick 5
    member private lp.LoopTickHandlerReduced6 () = lp.LoopTick 6
    member private lp.LoopTickHandlerReduced7 () = lp.LoopTick 7
    member private lp.LoopTickHandlerReduced8 () = lp.LoopTick 8
    member private lp.LoopTickHandlerReduced9 () = lp.LoopTick 9
    
    // ---- ---- ---- ---- ---- ----
    // #endregion
    
    /// A short-cut for 'Planetarium.GetUniversalTime ()'.
    /// A context argument is passed solely to be able to log an error message
    /// if the planetarium is unable to tell the current universal time.
    member private monitor.GetPlanetTime (context: LoopMessageTick) =
      try
        Planetarium.GetUniversalTime ()
       with exn ->
        sprintf "%s (%A): Planetarium.GetUniversalTime () failed." monitor.name context
        |> UtilityModule.LogWarn
        0.
    
    /// Helper function that gives you the name of the private loop tick
    /// handler corresponding to a particular tick variant.
    member private monitor.LoopHandlerName (ticktype: LoopMessageTick) =
      match ticktype with
      | MainLoop -> "LoopTickHandlerMain"
      | ReducedLoop n when (n > 0) && (n < 10)
        -> sprintf "LoopTickHandlerReduced%1d" n
      | ReducedLoop _ -> invalidArg "ticktype" "Only auxiliary loops 1 through 9 are defined."
    
    /// Start a loop that generate loop tick messages (sent to Callback).
    /// The loop setup is performed by Unity's 'InvokeRepeating'.
    member public monitor.InvokeLoop (timing: LoopTimingInformation) =
      let loopid = timing.LoopId
      let cbname = monitor.LoopHandlerName loopid
      if monitor.IsInvoking cbname
       then monitor.LogFn <| sprintf "Cancel '%s' before resetting." cbname
            monitor.CancelInvoke cbname
      earliestTickTime.[loopid.Nb] <- monitor.GetPlanetTime loopid
      minimumTickDelta.[loopid.Nb] <- timing.MinimumDeltaUT
      try
        monitor.InvokeRepeating (cbname, timing.InitialDelay, timing.RepeatDelay)
       with exn ->
        sprintf "%s (%A): Could not invoke repeating callback." monitor.name loopid
        |> UtilityModule.LogError
    
    /// End a loop that was started by InvokeLoop.
    member public monitor.CancelLoop (loopid: LoopMessageTick) =
      let cbname = monitor.LoopHandlerName loopid
      if monitor.IsInvoking cbname
       then monitor.CancelInvoke cbname
       else sprintf "Cannot cancel callback '%s' for %s; the callback is not active." cbname monitor.name
            |> UtilityModule.LogWarn
    
    /// Add hardcoded event callback forwarders (forwarding to 'Callback').
    /// It is possible, but not recommended, to add callbacks more than once.
    /// By default 'AddCallbacks' is called from 'Start'.
    /// Notice: Loop callbacks are not added; use 'InvokeLoop' for that.
    member public monitor.AddCallbacks () =
      addcallback GameEvents.onGameStateCreated.Add
                  GameEvents.onGameStateCreated.Remove
                  (new EventData.OnEvent<_> (monitor.GameStateCreated))
      addcallback GameEvents.onGameStateSaved.Add
                  GameEvents.onGameStateSaved.Remove
                  (new EventData.OnEvent<_> (monitor.GameStateSaved))
      addcallback GameEvents.onGameStateLoad.Add
                  GameEvents.onGameStateLoad.Remove
                  (new EventData.OnEvent<_> (monitor.GameStateLoad))
      addcallback GameEvents.onGameStatePostLoad.Add
                  GameEvents.onGameStatePostLoad.Remove
                  (new EventData.OnEvent<_> (monitor.GameStatePostLoad))
      addcallback GameEvents.onGameStateSave.Add
                  GameEvents.onGameStateSave.Remove
                  (new EventData.OnEvent<_> (monitor.GameStateSave))
      addcallback GameEvents.onLevelWasLoaded.Add
                  GameEvents.onLevelWasLoaded.Remove
                  (new EventData.OnEvent<_> (monitor.LevelWasLoaded))
      addcallback GameEvents.onLevelWasLoadedGUIReady.Add
                  GameEvents.onLevelWasLoadedGUIReady.Remove
                  (new EventData.OnEvent<_> (monitor.LevelWasLoadedGUIReady))
      addcallback GameEvents.onGUIApplicationLauncherReady.Add
                  GameEvents.onGUIApplicationLauncherReady.Remove
                  (new EventVoid.OnEvent (monitor.GUIApplicationLauncherReady))
      addcallback GameEvents.onGameSceneSwitchRequested.Add
                  GameEvents.onGameSceneSwitchRequested.Remove
                  (new EventData.OnEvent<_> (monitor.GameSceneSwitchRequested))
      addcallback GameEvents.onGameSceneLoadRequested.Add
                  GameEvents.onGameSceneLoadRequested.Remove
                  (new EventData.OnEvent<_> (monitor.GameSceneLoadRequested))
      addcallback GameEvents.OnGameSettingsApplied.Add
                  GameEvents.OnGameSettingsApplied.Remove
                  (new EventVoid.OnEvent (monitor.GameSettingsApplied))
      addcallback GameEvents.onGamePause.Add
                  GameEvents.onGamePause.Remove
                  (new EventVoid.OnEvent (monitor.GamePause))
      addcallback GameEvents.onGameUnpause.Add
                  GameEvents.onGameUnpause.Remove
                  (new EventVoid.OnEvent (monitor.GameUnpause))
      addcallback GameEvents.onGameSceneLoadRequested.Add
                  GameEvents.onGameSceneLoadRequested.Remove
                  (new EventData.OnEvent<_> (monitor.TrackGameSceneLoadRequested))
      addcallback GameEvents.onLevelWasLoaded.Add
                  GameEvents.onLevelWasLoaded.Remove
                  (new EventData.OnEvent<_> (monitor.TrackLevelWasLoaded))
    
    /// Remove the event callbacks and cancel active loop callbacks.
    /// By default 'RemoveCallbacks' is called from 'onDestroy'.
    member public monitor.RemoveCallbacks () =
      for n = 9 downto 0
       do // better safe than sorry - so we check with Unity if any of the loop callbacks are invoking
          let loopid = LoopMessageTick.ofNb n
          let cbname = monitor.LoopHandlerName loopid
          if monitor.IsInvoking cbname
           then monitor.LogFn <| sprintf "Cancel loop (%A) to remove callback." loopid
                monitor.CancelLoop loopid
      removecallbacks () // removes the event callbacks
  
